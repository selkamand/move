% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transformations.R
\name{compute_plane_from_points}
\alias{compute_plane_from_points}
\title{Fit a plane to 3D points}
\usage{
compute_plane_from_points(points, careful = TRUE)
}
\arguments{
\item{points}{A data frame or matrix with numeric columns \code{x}, \code{y},
and \code{z} giving point coordinates.}

\item{careful}{Logical; if \code{TRUE} (default), run basic input assertions
(presence of \code{x}, \code{y}, \code{z} columns and at least one row).}
}
\value{
For \strong{more than three} points, a list with components:
\describe{
\item{normal}{Numeric length-3 unit normal vector (named \code{x}, \code{y}, \code{z}).}
\item{offset}{Numeric scalar \code{d} in the plane equation \code{normal Â· x + d = 0}.}
}
For \strong{exactly three} points, a numeric length-3 unit normal vector is
returned.
}
\description{
Fits a geometric plane to a set of 3D points given in columns \code{x}, \code{y}, and \code{z}.
For exactly three non-collinear points, the plane normal is computed analytically
from the cross product of two spanning vectors. For more than three points, a
least-squares best-fit plane is obtained via singular value decomposition (SVD)
of the centered coordinates.
}
\details{
The fitted plane is of the form
\deqn{n \cdot x + d = 0}
where \code{n} is a unit normal vector and \code{d} is the scalar offset.

For \code{n > 3} points, the coordinates are first translated so that their
geometric center lies at the origin, and SVD is applied to the centered
\code{(x,y,z)} matrix. The plane normal is taken as the right singular vector
corresponding to the smallest singular value; the offset is then chosen so
that the plane passes through the original centroid.

The function errors if fewer than three points are supplied.
}
\examples{
# Simple plane: z = 0 (points in the xy-plane)
pts <- data.frame(
  x = c(0, 1, 2, 0),
  y = c(0, 0, 1, 2),
  z = 0
)
compute_plane_from_points(pts)

# Exactly three points defining a plane
pts3 <- data.frame(
  x = c(0, 1, 0),
  y = c(0, 0, 1),
  z = c(0, 0, 0)
)
compute_plane_from_points(pts3)

}
